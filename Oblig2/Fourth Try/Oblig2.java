import java.util.ArrayList;import java.util.concurrent.CyclicBarrier;public class Oblig2 { public static void main(String[] args) {  int nrRuns = 7;  for(int i = 2000000; i <= 2000000000 ; i*=10){   long totalSekvensiellNtime = 0;   long totalParallellNtime = 0;   long start, elapsedTime;   for(int j = 0; j < nrRuns; j++){    /*start = System.nanoTime();    sekvensiell(i);    elapsedTime = System.nanoTime() - start;    elapsedTime /= 1000000000.0;    System.out.println("Sekvensiell: Round " + j + " time:\t" + elapsedTime);    totalSekvensiellNtime += elapsedTime;*/    start = System.nanoTime();    parallell(i);    elapsedTime = System.nanoTime() - start;    elapsedTime /= 1000000000.0;    System.out.println("Parallell: Round " + j + " time:\t" + elapsedTime);    totalParallellNtime += elapsedTime;  }   System.out.println("" + totalSekvensiellNtime);   System.out.println("" + totalParallellNtime);  } } public static void sekvensiell(int maxNum){  EratosthenesSil es = new EratosthenesSil(maxNum);  es.generatePrimesByEratosthenes();  long num = maxNum * maxNum;  es.factorize(num);  es.printAllPrimes(); } public static void parallell(int maxNum){  EratosthenesSil es = new EratosthenesSil(maxNum);  int nrCores = Runtime.getRuntime().availableProcessors();  System.out.println("initialization...");  ArrayList<Integer> startprimes = es.getSqrtPrimes();  System.out.println("Threads is starting...");  CyclicBarrier cb = new CyclicBarrier(nrCores+1);  for(int i = 0; i < nrCores; i++){   EratosthenesSilThreads esi = new EratosthenesSilThreads(i, cb);   Thread t = new Thread(esi);   t.start();  }  try{   cb.await();  } catch(Exception e){   //do something with the cb  }  System.out.println("factorization...");  CyclicBarrier cb2 = new CyclicBarrier(nrCores+1);  for(int i = 0; i < nrCores; i++){   FactorizationThreads ft = new FactorizationThreads(i, cb2);   Thread t = new Thread(ft);   t.start();  }  try{   cb2.await();  } catch(Exception e){   //do something with the cb  } } public static class EratosthenesSilThreads implements Runnable{  CyclicBarrier cb;  public EratosthenesSilThreads(int ind, CyclicBarrier cb){    this.cb = cb;  }  public void run(){   try{    cb.await();   } catch(Exception e){   }  } } public static class FactorizationThreads implements Runnable{  CyclicBarrier cb;  public FactorizationThreads(int ind, CyclicBarrier cb){   this.cb = cb;  }  public void run(){   try{    cb.await();   } catch(Exception e){   }  } } public static class EratosthenesSil {  byte [] bitArr ;           // bitArr[0] represents the 7 integers:  1,3,5,...,13, and so on  int bitPrByte = 7;  int  maxNum;               // all primes in this bit-array is <= maxNum  final  int [] bitMask = {1,2,4,8,16,32,64};  // kanskje trenger du denne  final  int [] bitMask2 ={255-1,255-2,255-4,255-8,255-16,255-32,255-64}; // kanskje trenger du denne     ArrayList<Long> fakt;     CyclicBarrier cb;   EratosthenesSil (int maxNum) {     this.maxNum = maxNum;   bitArr = new byte [(maxNum/14)+1];   setAllPrime();   fakt = new ArrayList<Long>();  }   void printBytes(){    for (int i = 0; i < bitArr.length; i++) {     System.out.println(Integer.toBinaryString(bitArr[i]));    }   }    void setAllPrime() {     for (int i = 0; i < bitArr.length; i++) {       bitArr[i] = (byte)127;       }     }       void crossOut(int i) {        // set as not prime- cross out (set to 0)  bit represening 'int i              int bytenum = i/(bitPrByte*2);              int bitnuminByte = (i%(bitPrByte*2))/2;              bitArr[bytenum] = (byte) (bitArr[bytenum] & ~(1 << bitnuminByte));     } //       boolean isPrime (int val) {        /*særskilt test for å teste at partall er under 2.*/        if(val == 2){         return true;        } else if(val % 2 == 0){         return false;        }   int bytenum = val/(bitPrByte*2);         int bitnuminByte = (val%(bitPrByte*2))/2;         return (bitArr[bytenum] & (1 << bitnuminByte)) != 0;   }       long currNum = 0;       boolean stop = true;       public ArrayList<Long> getFakt(){        fakt.add(currNum);        return fakt;       }       public void initializefactorization(long num){        this.currNum = num;       }    ArrayList<Long> factorize (long num) {     ArrayList <Long> fakt = new ArrayList <Long>();    for(int idx = 2; idx <= num; idx++){     if(num % idx == 0 && isPrime(idx)){      num = num / idx;      fakt.add((long) idx);      idx = 1; //restarter for-løkken      //break;     }    }    fakt.add((long) num);     return fakt;    } // end factorize      public int nextPrime(int num) {      // returns next prime number after number 'i'        if(num < 2){         return 2;        }         num++; //for aa finne storre nummer         if(num % 2 == 0){ //for aa ikke returnere partall         num++;        }        for(; num < maxNum; num += 2){         int piv = 2;         for(; (num % piv) != 0; piv++){}         if(num == piv){       return num;      }        }           return num; //have not find a prime     } // end nextTrue   void printAllPrimes(){    for ( int i = 2; i <= maxNum; i++)     if (isPrime(i)) System.out.println(" "+i);   }    void generatePrimesByEratosthenes() {     // krysser av alle  oddetall i 'bitArr[]' som ikke er primtall (setter de =0)       crossOut(1);      // 1 is not a prime          int prime = 3;          while(prime < Math.sqrt(maxNum)){            int doubleprime = prime*prime;        int piv = doubleprime;        System.out.println(prime);            for(int i = 0; piv < maxNum ; i++){         if (piv % 2 != 0){          crossOut(piv);         }             piv = doubleprime + 2*i*prime;            }            prime = nextPrime(prime);          }     } // end generatePrimesByEratosthenes    ArrayList<Integer> getSqrtPrimes() {          ArrayList<Integer> primes = new ArrayList<Integer>();          int currprime = 3;          while(currprime < Math.sqrt(maxNum)){            primes.add(currprime);            currprime = nextPrime(currprime);          }          return primes;     } // end generatePrimesByEratosthenes } // end class Bool}
